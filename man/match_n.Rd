% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/match_n.R
\name{match_n}
\alias{match_n}
\title{Batch template matching}
\usage{
match_n(
  df_grid,
  score_method = "cor",
  ncores = 1,
  output = "detections",
  output_file = NULL,
  autosave_action = "replace",
  buffer_size = "template",
  min_score = NULL,
  min_quant = NULL,
  top_n = NULL
)
}
\arguments{
\item{df_grid}{The output of the function 'fetch_match_grid()}

\item{score_method}{A character string indicating the method to use for
matching. The two methods available are: "cor" (Pearson correlation
coefficient) or "dtw" (dynamic time warping). It defaults to "cor".}

\item{ncores}{An integer indicating the number of cores to be used for
parallelization. It defaults to 1.}

\item{output}{A character string indicating the output of the function. The
two options are: "detections" or "scores". If "detections" is selected, the
function will return the output of the function 'fetch_score_peaks_i()'. If
"scores" is selected, the function will return the raw output of the
matching algorithm. It defaults to "detections".}

\item{output_file}{A character string indicating the path to save the results
in the format of a CSV file for detections or RDS file for scores. Default
is NULL. We recommend to export detection or raw score files to the
"080_detections/" subdirectory.}

\item{autosave_action}{A character string indicating the action to be taken
if the output file already exists. Possible values are "append" and
"replace". To avoid overwriting existing files, set to "append", but be
aware that it can result in duplicated entries in the output file if the
function is run again. It defaults to "replace".}

\item{buffer_size}{A character string indicating the size of the buffer to be
used in the function 'fetch_score_peaks_i()'. The two options are:
"template" or the number of frames of the template spectrogram to be used
as buffer. It defaults to "template".}

\item{min_score}{A numeric value indicating the minimum score to be used in
the function 'fetch_score_peaks_i()'. It defaults to NULL.}

\item{min_quant}{A numeric value indicating the minimum quantile to be used
in the function 'fetch_score_peaks_i()'. It defaults to NULL.}

\item{top_n}{A numeric value indicating the number of top detections to be
used in the function 'fetch_score_peaks_i()'. It defaults to NULL.}
}
\value{
If the format is set to scores, a tibble containing the input data
  frame with an additional column "score_vec". This column contains
  dataframes with "time_vec" (time of each frame) and "score_vec" (matching
  score at that frame) columns. The scores are padded at the start and end to
  match the soundscape spectrogram length. If the format is set to
  detections, the function returns a data frame with the detections. If no
  paths are provided, the output are returned to the R session.
}
\description{
`r lifecycle::badge("experimental")`

  This function is wrapper of 'match_i()' to perform a batch computation of
  the matching vectors of the template and soundscape matches defined in the
  metadata grid obtained as output of the function 'fetch_match_grid()'. The
  available algorithms to compare spectrograms and compute matching scores
  are the Pearson correlation coefficient ("cor") or dynamic time warping
  ("dtw").
}
\examples{
\dontrun{
library(monitoraSom)
library(dplyr)
library(tuneR)

# Load the soundscape list to populate the example data
data(ls_soundscapes)

# Create a directory to store the soundscapes
soundscapes_path <- "./010_soundscapes"
dir.create(soundscapes_path)
invisible(lapply(1:length(ls_soundscapes), function(i) {
  writeWave(
    ls_soundscapes[[i]], file.path(soundscapes_path, names(ls_soundscapes)[i])
  )
}))

# Load the templates to populate the example data
data(ls_templates)

# Create a directory to store the templates
templates_path <- "./040_roi_cuts"
dir.create(templates_path)
invisible(lapply(1:length(ls_templates), function(i) {
  writeWave(
    ls_templates[[i]], file.path(templates_path, names(ls_templates)[i])
  )
}))

# Import the soundscapes and templates as dataframes
df_soundscapes <- fetch_soundscapes_metadata(
  soundscapes_path = soundscapes_path
)

# Import the templates as a dataframe
df_templates <- fetch_template_metadata(templates_path = templates_path)

# Create a match grid
df_grid <- fetch_match_grid(
  soundscape_data = df_soundscapes, template_data = df_templates
)

# Run the template matching to store raw scores of the first ten matches
df_scores <- match_n(
  df_grid = df_grid[1:10, ], score_method = "cor", output = "scores"
)
# Look into the whole results
glimpse(df_scores)
# Look into the raw score vector of the first match
glimpse(df_scores$score_vec[1])

# Run the template matching to get the raw detections
df_detecs <- match_n(
  df_grid = df_grid[1:10, ], score_method = "cor", output = "detections"
)
# Look into the whole results
glimpse(df_detecs)
# make a histogram of the scores of the detections
hist(df_detecs$peak_score, breaks = 100)

}
}
