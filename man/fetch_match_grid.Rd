% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/fetch_match_grid.R
\name{fetch_match_grid}
\alias{fetch_match_grid}
\title{Creates a grid with all combinations of templates and soundscapes for
template matching}
\usage{
fetch_match_grid(soundscape_data, template_data)
}
\arguments{
\item{soundscape_data}{A data frame containing metadata about the soundscapes
to be matched.}

\item{template_data}{A data frame containing metadata about the templates to
be matched.}
}
\value{
A data frame with a grid of all possible matching combinations
  between the two input data sets. In other words, each row of the output
  data frame represents the match between a template and a soundscape. All
  columns with metadata from soundscapes and templates are kept (see the
  documentation of the functions 'fetch_soundscape_metadata()' and
  'fetch_template_metadata()' for more details).
}
\description{
`r lifecycle::badge("experimental")`

  This function takes in two data frames: soundscape_data (the output of the
  function 'fetch_soundscape_metadata()') and template_data (the output of
  the function 'fetch_template_metadata()'), checks their compatibilities,
  and returns a new data frame with a grid of all possible matching
  combinations between the two data sets.
}
\examples{
\dontrun{

# Load the necessary packages to run this example
library(monitoraSom)
library(dplyr)
library(tuneR)

# Load the soundscape list and the template list to populate the example data
data(ls_soundscapes)
data(ls_templates)

# Create a directory and export the soundscapes
soundscapes_path <- "./soundscapes"
dir.create(soundscapes_path)
invisible(lapply(1:length(ls_soundscapes), function(i) {
  writeWave(
    ls_soundscapes[[i]], file.path(soundscapes_path, names(ls_soundscapes)[i])
  )
}))

# Create a directory and export the templates
templates_path <- "./templates"
dir.create(templates_path)
invisible(lapply(1:length(ls_templates), function(i) {
  writeWave(
    ls_templates[[i]], file.path(templates_path, names(ls_templates)[i])
  )
}))

# Import the soundscapes metadata
df_soundscapes <- fetch_soundscapes_metadata(
  soundscapes_path = soundscapes_path
)

# Import the templates metadata
df_templates <- fetch_template_metadata(templates_path = templates_path)

# Create a match grid
df_grid <- fetch_match_grid(
  soundscape_data = df_soundscapes, template_data = df_templates
)
glimpse(df_grid)

# Check if there is one match per soundscape-template pair in the grid. The test
# should return TRUE
nrow(df_grid) == length(ls_soundscapes) * length(ls_templates)

}
}
