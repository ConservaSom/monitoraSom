% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/plot_scores_i.R
\name{plot_scores_i}
\alias{plot_scores_i}
\title{Plot scores and detections of one template match run}
\usage{
plot_scores_i(
  df_scores_i,
  buffer_size = "template",
  min_score = NULL,
  min_quant = NULL,
  top_n = NULL,
  zoom_freq = NULL,
  zoom_time = NULL,
  zoom_score = NULL,
  ovlp = NULL,
  wl = NULL,
  dyn_range = NULL,
  color_scale = "inferno",
  n_colors = 124,
  interpolate = FALSE,
  ...
)
}
\arguments{
\item{df_scores_i}{One row of the output of `match_n` containing the raw
scores of a template match run.}

\item{buffer_size}{A numeric value specifying the number of frames of the
buffer within which overlap between detections is avoided. Defaults to
"template", which means that the buffer size equals the number of frames
present in the template spectrogram. The buffer exclusion priority is
oriented by score quantiles, so that the highest scoring detections are
always kept. Setting the buffer size to 0 disables the exclusion buffer.}

\item{min_score}{A numeric value between 0 and 0.99 indicating the minimum
score of the detections that will be kept. Defaults to NULL, which returns
all available detections.}

\item{min_quant}{A numeric value between 0 and 1 indicating the minimum score
quantile of the kept detections. Defaults to NULL, which returns all
available detections.}

\item{top_n}{An integer indicating the maximum number of peaks to be
returned, selected according to the highest scores available. Defaults to
NULL, which return all available detections. It should be noted that
because the peak quantiles are callculated within each score vector, the
top_n parameter is applied to each score vector separately, and not to the
whole matching grid.}

\item{zoom_freq}{Set frequency limits for the spectrogram panel}

\item{zoom_time}{Set time limits for the spectrogram panel.}

\item{zoom_score}{A numeric vector of length 2 specifying the score range to
be displayed.}

\item{ovlp}{A numeric value specifying the percentage overlap of windows in
the spectrogram calculation. Defaults to NULL, which uses the value
obtained from df_scores_i, but overrides it if a value is provided.}

\item{wl}{An integer specifying the length of the FFT window used to
calculate the spectrogram. Defaults to NULL, which uses the value obtained
from df_scores_i, but overrides it if a value is provided.}

\item{dyn_range}{A numeric vector of length 2 giving the minimum and maximum
values of relative amplitude to be displayed in the spectrogram.}

\item{color_scale}{A character string specifying the color scale to be used
in the spectrogram. Possible values are "viridis", "magma", "inferno",
"cividis", "greyscale 1", or "greyscale 2".}

\item{n_colors}{An integer specifying the number of colors to be used in the
color scale. Smaller values will result in lower resolution color scales,
but will also result in faster rendering times.}

\item{interpolate}{A logical value indicating whether the raster should be
interpolated or not.}

\item{...}{Other arguments passed to the seewave::spectro() function}
}
\value{
Todo
}
\description{
`r lifecycle::badge("experimental")`

  This function plots a spectrogram of the soundscape and the results of the
  match_i() and fetch_score_peaks_i() functions.
}
\examples{
\dontrun{

# Load the necessary packages to run this example
library(monitoraSom)
library(dplyr)
library(tuneR)

# Load the soundscape list to populate the example data
data(ls_soundscapes)

# Create a directory to store the soundscapes
soundscapes_path <- "./010_soundscapes"
dir.create(soundscapes_path)
invisible(lapply(1:length(ls_soundscapes), function(i) {
  writeWave(
    ls_soundscapes[[i]], file.path(soundscapes_path, names(ls_soundscapes)[i])
  )
}))

data(df_scores)

# Plot the scores of the 20th match with the default parameters. It gets most
# peaks, but several false positives and the spectrogram is not very
# informative.
plot_scores_i(df_scores_i = df_scores[20, ])

# Now with filtered scores and adjusted spectrogram parameters. Now we can see
# the target signals more clearly, but we still have some false positives.
plot_scores_i(
  df_scores_i = df_scores[20, ], ovlp = 50, wl = 512, dyn_range = c(-90, -30)
)

# Now lets turn of the default detection filters to have a look at the
# detections obtained without any filtering. We can barely see the target
# signals among so many false positives.
plot_scores_i(
  df_scores_i = df_scores[20, ], ovlp = 50, wl = 512, dyn_range = c(-90, -30),
  buffer_size = 0, min_score = NULL, min_quant = NULL, top_n = NULL
)

# Now lets improve the filters so that only true positives are shown as
# detections. We set a minimum score of 0.3 and a minimum quantile of 0.9.
plot_scores_i(
  df_scores_i = df_scores[20, ], ovlp = 50, wl = 512, dyn_range = c(-90, -30),
  buffer_size = 0, min_score = 0.3, min_quant = 0.9, top_n = NULL
)

# Now lets zoom in one detection to see the details. We can notice that the
# template has a target siognal that matches the final two notes of the target
# species' song
plot_scores_i(
  df_scores_i = df_scores[20, ],
  buffer_size = "template", min_score = 0.3, min_quant = NULL, top_n = NULL,
  ovlp = 50, wl = 512, dyn_range = c(-90, -30),
  zoom_freq = c(2, 10), zoom_time = c(20, 25)
)

}
}
