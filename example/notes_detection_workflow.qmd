---
title: "Template Matching Notes"
author: "GLMRosa"
format: pdf
---

monitoraSom v0.1.1.9003:
- Função `diagnostic_validations_i()` destinada à extrair as métricas de qualidade e nivel de corte das validações (independente da origem).
- Novo default para dyn_range em `plot_detecs_i()`.
- A função `validate_by_overlap_i()` está em vias de ser descartada de `validate_by_overlap_n()`, que não requer mais que o usuário define a espécie de interesse, mas trabalha com todas as espécies presentes na tabela de detecções de forma simultânea. Porém, os resultados ainda são organizados na form de um um único dataframe, e não mais em uma lista de dataframes em que cada elemento eram as detecs de um template. Ajustes para uso como input da função `diagnostic_validations_i()` ainda são necessários.
- App de validação
  - A posição do sonograma da detecção agora é à esquerda para maior destaque em relação ao do template.
  - Agora o app não buga mais quando os template não são encontrados na pasta de templates, mas o painel do sonograma passa a mostrar a mensagem "Template not available".
  - correção de bug - agora subsets com somente um valor de scores não geram mais o travamento do app.
  - compartibilidade com BirdNET
    - Foi criada a função `import_external_detections()` para importar as detecções do BirdNET e convertê-las para o formato de output da função `fetch_score_peaks_i()`. Essa função pode ser usada para importar isso diretamente para a sessão caso `output_path = NA`. Se o usuario deseja salvar, deve fornecer um caminho para o arquivo .csv de saída em `output_path`. Os caminhos dos argumentos de entrada e saída devem ser diferentes para que não seja sobrescrito o arquivo de entrada. Atenção! Considerando a necessidade de renomear as variáveis, mas admitindo que haverá variação, podem ser repassados os nomes das variáveis necessárias em forma de um vetor por meio do argumento `names_vec` (ver o default na vignette de ajuda da função). Os nomes correspondem aos nomes das variáveis usados por default pelo birdnet (até onde eu consegui checar), mas existe alguma variação.
    - Não é mais necessário ter um template para poder validar as detecções. O app considera cada espécie como um template e mostra a mensagem "Template not available" no lugar onde deveria estar o sonograma do template.
    - As tabelas de detecções do BirdNET devem ser adaptadas para o formato identico ao do output da função `fetch_score_peaks_i()`. Uma função específica para essa conversão ainda será implementada.


- adicionar um menu com o nome da espécie com cadeado
- Segunda camada de classificação para mitigação de falsos positivos ou desambiguação entre espécies com cantos similares

- next unsegmented no app de segmentação não está navegando direito

- Mostrar a probabilidade do modelo binomial quando disponivel (Deixar pra depois pq depender de atualizações independentes do modelo exige um pouco mais de cuidado pra prevenir bugs)

Prioridades
- Implementar o restante dos diagnósticos
- A validação deve retornar 3 objetos: o valor do score selecionado, a tabela de diagnosticos baseados nesse score e a tabela de detecs validadas.

Funções
- Fazer uma função para extração dos metadados a partir de nomes de arquivos e metadados de arquivos audiomoths e sm4
- Fazer uma função para adaptar um corte de audio qualquer como template
- Fazer função para conversão entre tabelas de seleção do raven, birdnet e audacity para roi_tables
  - Criar funções para que sejam convertidas tabelas de seleção do Raven e Audacity para o formato de output do app de segmentação
- Deprecate roi tables como formato de templates
- Função de match_n tem que checar o caminho para o salvamento antes de processar tudo
- Implementar função de diagnóstico de template

Geral
- Adicionar contador de tempo para as funções de processamento mais longo
- pasta data/ com objetos para exemplos de todas as funções
  - (Um exemplo de três templates e três soundscapes para o template matching
  - uma tabelona com detecções para exemplo de validação
  - link estável para baixar dados de exemplos maiores
  - Fazer um Rdata que exporta os arquivos para um diretório de exemplo
- remover as paradas do vs code do repo
- Adicionar opções gerais para seleção e registro do canal onde cada processo foi feito

Apps
- Adicionar autoplay onde puder ser necessário
- Adicionar checkbox para inversão das escalas de cores dos sonogramas
- Simplificar o app com a remoção de seções duplicadas do código para acesso por diferentes tipos de inputs, como hotkeys e actionButtons ao mesmo tempo.
- Streaming dos dados em um banco de dados em SQL
- Adicionar opção para selecionar o canal do sonograma visível
- Encontrar e resolver o bug de renderização duplicada dos sonogramas
- Fazer um painel com metadados da soundscape em ambos os apps
- Validação:
  - fazer 'play' como 'R session' funcionar em windows
  - Fazer um segundo conjunto de dados de demonstração, maior para varificar questões de performance
  - Adicionar seed específica para os diagnósticos
  - Modificar o sistema para que seja possível haver mais de uma validação por detecção, caso seja um usuário diferente.
  - Habilitar a navegaçao entre soundscapes
- Segmentação
  - Ativar mecanismo de detecção de sistema para os players
    - Detectar se o sox está disponível?
    - Pedir caminho para o player quando houver "R session" no windows
    - Apresentar erro de detecção se o sox não estiver disponível no linux ou no mac
  - verificar os padrões usados em https://esajournals.onlinelibrary.wiley.com/doi/10.1002/ecy.3329
  - Progresso
    - Rever o que é informado na barra de progresso
    - Alimentar uma unica tabela ao inves de uma tabela por arquivo?
  - Adicionar um campo com uma lista em que persistem as tags mais usadas em ordem aflabética que possam ser clicadas facilmente para preencher todos os campos (exceto a observação). Essas opções devem ser clicáveis.

fetch_score_peaks_i()
- Verificar se `fetch_score_peaks_i()` deve desligar um dado filtro e retornar todas as detecções no caso de não restar nenhuma detecção após o filtro. Valeria a pena fazer a função retornar um dataframe vazio?

fetch_score_peaks_n()
- Adicionar paralelização

Funções novas
- Fazer uma terceira função com o split e serialização de batches muito grandes para salvamento em multiplos arquivos rds ou uma alternativa para streaming dos resultados para uma base de dados onde seja possível fazer a consulta de ter ou não sido feito o mesmo template matching antes do processamento para evitar a duplicação de resultados ou processamento desnecessário.
- Criar a função set_paths() com checagens para facilitar a definição dos diretórios



### Perguntas importantes
- Quais são os efeitos dos filtros de detecções baseados nos scores sobre os diagnosticos?
- Como lidar com multiplas validações de usuários diferentes para um mesmo conjunto de detecções? Como processar % de TP e FP para os diagnósticos?
- Qual é o efeito dos pads de tempo e frequência para a detecção?
- Quais são as espécies que quando aparecem na gravação fazer o usuário demorar mais pra segmentar?

### Para depois
- App de segmentação
  - Player focal
    - ROIs selecionadas na tabela são concatenadas e tocadas em sequência
    - Caso não haja nenhuma selecionada, toca a mais recente
    - Adicionar checkbox para aplicar filtros de banda sobre os sons tocados
  - Dar ao usuário a possibilidade de editar o nome da tabela de rois?
  - Escolha entre segmentação com atribuição prévia ou posterior dos metadados de cada roi. No modo de atribuição posterior, inputs são dados em uma pop-up, sendo que o usuário tem a opção de omitir essa pop-up repetindo os metadados atribuídos anteriormente. Isso permitiria um modelo de edição de rois ativas similar à do Raven.
  - bug das Renderização duplicada de sonograma
    - O processamento das ROIs disponíveis acaba depois da renderização, fazendo com que seja feita a renderização uma segunda vez para inclui-las
  - Adicionar um sonograma de panorama para navegar no da soundscape
  - Usar o file input como alternativa quando o app é usado de forma local, carregando diretamente os múltiplos arquivos que serão segmentados. Talvez seja interessante ter modos remoto e local



