---
title: "Template Matching Notes"
author: "GLMRosa"
format: pdf
---

Geral
- Trabalhar melhor no nome dos templates standalone
- Adiconar novamente a coluna template_name através de todo o fluxo de análise
- Adicionar dataframes que possam ser chamados de dentro do pacote pela função `data()`
- Adicionar contador de tempo para as funções de processamento mais longo
- Fazer com que as funções que plotam sonogramas dos apps usem a função fast_spectro()
- pasta data/ com objetos para exemplos de todas as funções
  - (Um exemplo de três templates e três soundscapes para o template matching
  - uma tabelona com detecções para exemplo de validação
  - link estável para baixar dados de exemplos maiores
  - Fazer um Rdata que exporta os arquivos para um diretório de exemplo
- Ver qual é a licensa das dependencias
- remover as paradas do vs code do repo

Apps
- Habilitar o acionamento dos apps por meio de função sem que todos os argumentos precisem ser definidos
- Adicionar autoplay onde puder ser necessário
- Adicionar checkbox para inversão das escalas de cores dos sonogramas]
- Adicionar filtro de banda e normalização para os sonogramas
- Controle para evitar que o path selecionado suma ao clicar adicentalmente no botão de load.
- Simplificar o app por meio de evitar seções duplicadas do código para acesso por diferentes tipos de inputs, como hotkeys e actionButtons ao mesmo tempo.
- Streaming dos dados em um banco de dados em SQL
- Validação:
  - Adicionar o score no sonograma da detec
  - Adicionar o prefixo "validation_preset" aos presets
  - Ok do dos warning está apagado
  - Verificar se o 'play' default para 'R session' funciona em windows
  - Diferenças no output são detectadas como unsaved rows, controlar quando o que acontece é a comparação de um dataset vazio com um cheio
  - Fazer um manual de uso da interface
  - Fazer um segundo conjunto de dados de demonstração, maior para varificar questões de performance
  - Verificar se funciona com o MonitoraSomAlt e formatos relacionados
  - Quando possível, mostrar a hora absoluta do sonograma da detecção
  - Adicionar seed específica para os diagnósticos
  - Adicionar opção para mostrar a sundscape somente na banda em zoom_freq
  - Modificar o sistema para que seja possível haver mais de uma validação por detecção, caso seja um usuário diferente.
  - Habilitar a navegaçao entre soundscapes
- Segmentação
  - Depositar as listas de espécies como um arquivo xlsx na pasta de roi_tables

fetch_score_peaks_i()
- Verificar se `fetch_score_peaks_i()` deve desligar um dado filtro e retornar todas as detecções no caso de não restar nenhuma detecção após o filtro. Valeria a pena fazer a função retornar um dataframe vazio?

Funções novas
- Fazer uma terceira função com o split e serialização de betches muito grandes para salvamento em multiplos arquivos rds ou uma alternativa para streaming dos resultados para uma base de dados onde seja possível fazer a consulta de ter ou não sido feito o mesmo template matching antes do processamento para evitar a duplicação de resultados ou processamento desnecessário.
- Criar a função set_paths() copm checagens para facilitar a definição dos diretórios
- Adicionar a função de validação por sobreposição temporal
- Fazer uma função para cortar rois tables em standalone templates em batch


### Perguntas importantes
- Quais são os efeitos dos filtros de detecções baseados nos scores sobre os diagnosticos?
- Como lidar com multiplas validações de usuários diferentes para um mesmo conjunto de detecções? Como processar % de TP e FP para os diagnósticos?



```{r}
library(monitoraSom)
launch_segmentation_app(
  preset_path = "/home/grosa/R_repos/MonitoraSomUI/ex_seg_small/presets/",
  preset_id = "default_linux2",
  user = "gabriel na função",
  soundscapes_path = "/home/grosa/R_repos/MonitoraSomUI/ex_seg_small/soundscapes",
  roi_tables_path = "/home/grosa/R_repos/MonitoraSomUI/ex_seg_small/roi_tables",
  cuts_path = "/home/grosa/R_repos/MonitoraSomUI/ex_seg_small/roi_cuts",
  labels_file = "/home/grosa/R_repos/MonitoraSomUI/ex_seg_small/presets/MonitoraSom_UI_label_lists.xlsx",
  fastdisp = TRUE, label_angle = 90, show_label = TRUE, dyn_range = c(-60, 0), wl = 1024,
  ovlp = 0, color_scale = "inferno", wav_player_type = "HTML player",
  # wav_player_path = "play",
  session_notes = NULL, zoom_freq = c(0, 10), nav_autosave = FALSE,
  sp_list = "CBRO-2021 (Brazil)"
)

session_preset <- readRDS("/home/grosa/R_repos/MonitoraSomUI/ex_seg_small/presets/segmentation_preset_default_windows.rds") %>%
    glimpse()

val_preset <- readRDS("/home/grosa/R_repos/MonitoraSomUI/ex_val_large/presets/preset_default_linux.rds") %>%
    glimpse()


# launch_validation_app()

```

Benchmarks
```{r}
teste <- bench::mark(
  seq = match_n(
    df_grid = df_grid[1:10, ], score_method = "cor", par_strat = "pbapply", ncores = 1
  ),
  future = match_n(
    df_grid = df_grid[1:10, ], score_method = "cor", par_strat = "future", ncores = 5
  ),
  foreach = match_n(
    df_grid = df_grid[1:10, ], score_method = "cor", par_strat = "foreach", ncores = 5
  ),
  pbapply = match_n(
    df_grid = df_grid[1:10, ], score_method = "cor", par_strat = "pbapply", ncores = 5
  ),
  parabar_async_sock = match_n(
    df_grid = df_grid[1:10, ], score_method = "cor", par_strat = "parabar", ncores = 5,
    backend_type = "async", cluster_type = "psock"
  ),
  parabar_sync_sock = match_n(
    df_grid = df_grid[1:10, ], score_method = "cor", par_strat = "parabar", ncores = 5,
    backend_type = "sync", cluster_type = "psock"
  ),
  parabar_async_fork = match_n(
    df_grid = df_grid[1:10, ], score_method = "cor", par_strat = "parabar", ncores = 5,
    backend_type = "async", cluster_type = "fork"
  ),
  parabar_sync_fork = match_n(
    df_grid = df_grid[1:10, ], score_method = "cor", par_strat = "parabar", ncores = 5,
    backend_type = "sync", cluster_type = "fork"
  ),
  iterations = 10, check = FALSE, memory = FALSE
)
plot(teste)

```

fetch_score_peaks_i()
```{r}
#' \itemize{
#'   \item \code{soundscape_path} {A character string specifying the full path to the soundscape WAV file.}
#'   \item \code{soundscape_file} {A character string specifying the name of the soundscape WAV file.}
#'   \item \code{template_path} {A character string specifying the complete path to the soundscape WAV files.}
#'   \item \code{template_file} {A character string specifying the name of the soundscape WAV files (without the complete path).}
#'   \item \code{template_min_freq} {The minimum frequency (kHz) of the band used to compute the template spectrogram.}
#'   \item \code{template_max_freq} {The maximum frequency (kHz) of the band used to compute the template spzectrogram.}
#'   \item \code{detection_start} {The start time (s) of the detection in the soundscape recording. Based on the template duration.}
#'   \item \code{detection_end} {The end time (s) of the detection in the soundscape recording. Based on the template duration.}
#'   \item \code{detec_wl} {The F tail temp
    template_comment template_end template_file templat {The value of 'min_score'.}
#'   \item \code{detec_min_quant} {The value of 'min_quant'.}
#'   \item \code{detec_top_n} {The value of 'top_n'.}
#'   \item \code{peak_index} {A numeric value representing the index of the score peak in the original score vector.}
#'   \item \code{peak_cor} {A numeric value between 0 and 1 with the detection score.}
#'   \item \code{peak_quant} {The quantile of the peak value in the score vector.}
#' }
```

fetch_soundscape_metadata
```{r}
#' \describe{
#' \item \code{soundscape_path} {A character string specifying the full path to the soundscape WAV file.}
#' \item \code{soundscape_file} {A character string specifying the name of the soundscape WAV file.}
#' \item \code{soundscape_duration} {A numeric value specifying the total duration (s) of the WAV file.}
#' \item \code{soundscape_sample_rate} {An integer specifying the sample rate of the WAV file in Hz.}
#' \item \code{soundscape_codec} {A character string specifying the audio codec used in the WAV file. See the documentation of the 'av' package for more details.}
#' \item \code{soundscape_layout} {A character string specifying the audio channel layout of the WAV file. See the documentation of the 'av' package for more details.}
#' }
```

fetch_template_metadata
```{r}
#' \itemize{
#' \item \code{template_path} {A character string specifying the complete path to the soundscape WAV files.}
#' \item \code{template_file} {A character string specifying the name of the soundscape WAV files (without the complete path).}
#' \item \code{template_label} {A character string specifying the label indicating the origin of the signal represented in the template.}
#' \item \code{template_start} {A numeric value representing the time (s) in which computation of the spectrogram starts within the template file.}
#' \item \code{template_end} {A numeric value representing the time (s) in which computation of the spectrogram ends within the template file.}
#' \item \code{template_sample_rate} {The sample rate of the template file.}
#' \item \code{template_min_freq} {The minimum frequency (kHz) of the band that will be used to compute the template spectrogram.}
#' \item \code{template_max_freq} {The maximum frequency (kHz) of the band that will be used to compute the template spectrogram.}
#' \item \code{template_wl} {The FFT window length used to compute the template spectrogram.}
#' \item \code{template_ovlp} {The overlap used to compute the template spectrogram.}
#' }
```