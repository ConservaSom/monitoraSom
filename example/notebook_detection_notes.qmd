---
title: "Template Matching Notes"
author: "GLMRosa"
format: pdf
---


- Verificar se `fetch_score_peaks_i()` deve desligar um dado filtro e retornar todas as detecções no caso de não restar nenhuma detecção após o filtro. Valeria a pena fazer a função retornar um dataframe vazio?
- Adicionar dataframes que possam ser chamados de dentro do pacote pela função `data()`
- Fazer uma terceira função com o split e serialização de betches muito grandes para salvamento em multiplos arquivos rds ou uma alternativa para streaming dos resultados para uma base de dados onde seja possível fazer a consulta de ter ou não sido feito o mesmo template matching antes do processamento para evitar a duplicação de resultados ou processamento desnecessário.
- Adiconar novamente a coluna template_name
- Adicionar o score no sonograma da detec
- Adicionar contador de tempo para as funções de processamento mais longo
- Fazer com que as funções que plotam sonogramas dos apps usem a função fast_spectro()
- Verificar se template_name é produzido mesmo quando os templates são baseados em tabelas de rois
- Adicionar o prefixo "validation_preset" no app de validação
- pasta data/ para armazenar os templates e os resultados do template matching
- Um exemplo de três templates e três soundscapes para o template matching
- uma tabelona com detecções para exemplo de validação
- link estável para baixar dados de exemplos maiores
- Ver qual é a licensa dos depends
- remover as paradas do vs code do repo
- Fazer um Rdata que exporta os arquivos para um diretório de exemplo
- Puxar as funções de validação do Juan
- Puxar a função de validaç~ao por sobreposição
- Preencher os dados no formato .RData
- Criar a função set_paths() copm checagens para facilitar a definição dos diretórios
- Fazer uma função para cortar rois tables em standalone templates em batch
- Trabalhar melhor no nome dos templates standalone

```{r}
library(monitoraSom)
launch_segmentation_app(
  preset_path = "/home/grosa/R_repos/MonitoraSomUI/ex_seg_small/presets/",
  preset_id = "default_linux2",
  user = "gabriel na função",
  soundscapes_path = "/home/grosa/R_repos/MonitoraSomUI/ex_seg_small/soundscapes",
  roi_tables_path = "/home/grosa/R_repos/MonitoraSomUI/ex_seg_small/roi_tables",
  cuts_path = "/home/grosa/R_repos/MonitoraSomUI/ex_seg_small/roi_cuts",
  labels_file = "/home/grosa/R_repos/MonitoraSomUI/ex_seg_small/presets/MonitoraSom_UI_label_lists.xlsx",
  fastdisp = TRUE, label_angle = 90, show_label = TRUE, dyn_range = c(-60, 0), wl = 1024,
  ovlp = 0, color_scale = "inferno", wav_player_type = "HTML player",
  # wav_player_path = "play",
  session_notes = NULL, zoom_freq = c(0, 10), nav_autosave = FALSE,
  sp_list = "CBRO-2021 (Brazil)"
)

session_preset <- readRDS("/home/grosa/R_repos/MonitoraSomUI/ex_seg_small/presets/segmentation_preset_default_windows.rds") %>%
    glimpse()

val_preset <- readRDS("/home/grosa/R_repos/MonitoraSomUI/ex_val_large/presets/preset_default_linux.rds") %>%
    glimpse()


# launch_validation_app()

```

Benchmarks
```{r}
teste <- bench::mark(
  seq = match_n(
    df_grid = df_grid[1:10, ], score_method = "cor", par_strat = "pbapply", ncores = 1
  ),
  future = match_n(
    df_grid = df_grid[1:10, ], score_method = "cor", par_strat = "future", ncores = 5
  ),
  foreach = match_n(
    df_grid = df_grid[1:10, ], score_method = "cor", par_strat = "foreach", ncores = 5
  ),
  pbapply = match_n(
    df_grid = df_grid[1:10, ], score_method = "cor", par_strat = "pbapply", ncores = 5
  ),
  parabar_async_sock = match_n(
    df_grid = df_grid[1:10, ], score_method = "cor", par_strat = "parabar", ncores = 5,
    backend_type = "async", cluster_type = "psock"
  ),
  parabar_sync_sock = match_n(
    df_grid = df_grid[1:10, ], score_method = "cor", par_strat = "parabar", ncores = 5,
    backend_type = "sync", cluster_type = "psock"
  ),
  parabar_async_fork = match_n(
    df_grid = df_grid[1:10, ], score_method = "cor", par_strat = "parabar", ncores = 5,
    backend_type = "async", cluster_type = "fork"
  ),
  parabar_sync_fork = match_n(
    df_grid = df_grid[1:10, ], score_method = "cor", par_strat = "parabar", ncores = 5,
    backend_type = "sync", cluster_type = "fork"
  ),
  iterations = 10, check = FALSE, memory = FALSE
)
plot(teste)

```

fetch_score_peaks_i()
```{r}
#' \itemize{
#'   \item \code{soundscape_path} {A character string specifying the full path to the soundscape WAV file.}
#'   \item \code{soundscape_file} {A character string specifying the name of the soundscape WAV file.}
#'   \item \code{template_path} {A character string specifying the complete path to the soundscape WAV files.}
#'   \item \code{template_file} {A character string specifying the name of the soundscape WAV files (without the complete path).}
#'   \item \code{template_min_freq} {The minimum frequency (kHz) of the band used to compute the template spectrogram.}
#'   \item \code{template_max_freq} {The maximum frequency (kHz) of the band used to compute the template spzectrogram.}
#'   \item \code{detection_start} {The start time (s) of the detection in the soundscape recording. Based on the template duration.}
#'   \item \code{detection_end} {The end time (s) of the detection in the soundscape recording. Based on the template duration.}
#'   \item \code{detec_wl} {The F tail temp
    template_comment template_end template_file templat {The value of 'min_score'.}
#'   \item \code{detec_min_quant} {The value of 'min_quant'.}
#'   \item \code{detec_top_n} {The value of 'top_n'.}
#'   \item \code{peak_index} {A numeric value representing the index of the score peak in the original score vector.}
#'   \item \code{peak_cor} {A numeric value between 0 and 1 with the detection score.}
#'   \item \code{peak_quant} {The quantile of the peak value in the score vector.}
#' }
```

fetch_soundscape_metadata
```{r}
#' \describe{
#' \item \code{soundscape_path} {A character string specifying the full path to the soundscape WAV file.}
#' \item \code{soundscape_file} {A character string specifying the name of the soundscape WAV file.}
#' \item \code{soundscape_duration} {A numeric value specifying the total duration (s) of the WAV file.}
#' \item \code{soundscape_sample_rate} {An integer specifying the sample rate of the WAV file in Hz.}
#' \item \code{soundscape_codec} {A character string specifying the audio codec used in the WAV file. See the documentation of the 'av' package for more details.}
#' \item \code{soundscape_layout} {A character string specifying the audio channel layout of the WAV file. See the documentation of the 'av' package for more details.}
#' }
```

fetch_template_metadata
```{r}
#' \itemize{
#' \item \code{template_path} {A character string specifying the complete path to the soundscape WAV files.}
#' \item \code{template_file} {A character string specifying the name of the soundscape WAV files (without the complete path).}
#' \item \code{template_label} {A character string specifying the label indicating the origin of the signal represented in the template.}
#' \item \code{template_start} {A numeric value representing the time (s) in which computation of the spectrogram starts within the template file.}
#' \item \code{template_end} {A numeric value representing the time (s) in which computation of the spectrogram ends within the template file.}
#' \item \code{template_sample_rate} {The sample rate of the template file.}
#' \item \code{template_min_freq} {The minimum frequency (kHz) of the band that will be used to compute the template spectrogram.}
#' \item \code{template_max_freq} {The maximum frequency (kHz) of the band that will be used to compute the template spectrogram.}
#' \item \code{template_wl} {The FFT window length used to compute the template spectrogram.}
#' \item \code{template_ovlp} {The overlap used to compute the template spectrogram.}
#' }
```